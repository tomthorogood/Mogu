#!/usr/bin/env python
CONFIG_FILE = "/etc/mogu/mogu.conf"

from mogu_py import *
from argparse import ArgumentParser
from redis import Redis
from ConfigParser import SafeConfigParser
from ConfigParser import NoOptionError

#import mogu.io
import sys
import os

config = SafeConfigParser()
config.read(CONFIG_FILE)

try:
    auth = config.get("redis_instance", "auth")
except NoOptionError:
    auth = None

parser = ArgumentParser(description="The command line utility for interacting with your Mogu web aplication")
parser.add_argument("command", nargs='+', type=str, action="store", help="The command you want to run (see readme for available commands")

#Mogu specific variables
parser.add_argument("--node-type", dest="node", type=str, action="store", help="The sort of node you're interacting with (event/widget)")


# Options for configuring your Redis connection
parser.add_argument("--redis-select", 
        type=int, dest="redis_db", 
        action="store", default=config.get("redis_instance","database"), 
        help="Optional Redis database number (default is read from config file)")

parser.add_argument("--redis-port", 
        type=int, dest="redis_port", 
        action="store", default=config.get("redis_instance","port"),
        help="Optional Redis port (default is read from config file)")

parser.add_argument("--redis-host", 
        type=str, dest="redis_host", 
        action="store", default=config.get("redis_instance","host"), 
        help="Optional Redis host (default is read from config file")

parser.add_argument("--redis-auth", 
        type=str, dest="redis_auth", action="store", 
        default=auth,help="Optional Redis auth password (can be set in config file)")

# Boolean options for interacting with the Redis environment
parser.add_argument("--redis-flush", 
        dest="flushdb", action="store_true", 
        default=False, 
        help="If importing a Mogu database, flushes the selected database first. CAREFUL!")

parser.add_argument("--assume-yes", 
        dest="yes", action="store_true", default=False, 
        help="Will assume yes to all questions. EXTRA CAREFUL!")

parser.add_argument("-v", "--verbose",
        dest="verbose", action="store_true", default=False,
        help="Will make the import command more verbose when assuming yes")

parser.add_argument("--test-only", 
        dest="testing", action="store_true", default=False, 
        help="Displays various information depending on the command, making no changes to your database.")

parser.add_argument("--filename", 
        dest="filename", action="store", default=None, 
        help="The filename that will be used by some commands, such as for importing or exporting. See the readme for extra information.")

parser.add_argument("--merge",
        dest="merge", action="store_true", default=False,
        help="Will not delete nodes before setting values, which could result in unexpected behaviour, but can make things easier when adding one-offs."
        )


args = parser.parse_args()

# Check for required commands and get confirmations for certain commands

command = args.command[0]

db = Redis(args.redis_host, args.redis_port, args.redis_db, args.redis_auth)

# mogu import filename F [--merge --redis-port --redis-host --redis-select --redis-auth --redis-flush --assume-yes --test-only]
if command == "import":
    pyFiles = []
    moguFiles = []

    for filename in args.command[1:]:
        if filename.endswith(".py"):
            pyFiles.append(filename)
        else:#Doesn't enforce the .mogu extension
            moguFiles.append(filename)
    importdb.import_files(db, args, moguFiles, pyFiles)

# mogu import-directory directory D [--merge --redis-port --redis-host --redis-select --redis-auth --redis-flush --assume-yes --test-only]
if command == "import-directory":
    for directory in args.command[1:]:
        dir_path = directory +"/"
        filenames = os.listdir(directory)

        pyFiles = []
        moguFiles = []

        for filename in filenames:
            if filename.endswith(".py"):
                pyFiles.append(dir_path+filename)
            elif filename.endswith(".mogu"):
                moguFiles.append(dir_path+filename)

        importdb.import_files(db, args, moguFiles, pyFiles)


# mogo export filename [--resis-port --redis-host --redis-select --redis-auth]
if command == "export":
    if len(args.command) is 1:
        error = fail("You have told me that you want to export the database, but have not given me a filename to write to.")
        print("%s\n You can fix this by using the --filename option. ex: ./mogu export --filename /path/to/file")%error
        sys.exit()
    
    export(db,args.command[1])

# mogu remove-child child-name [parent ...]
if command == "remove-child":
    child = args.command[1].replace("widgets.","")
    child = "widgets.%s" % child
    parents = None
    if len(args.command) > 2:
        parents = [arg for arg in args.command[2:]]
    if not parents:
        child_lists = [key for key in db.keys("*.children")]
        for node in child_lists:
            if child in db.lrange(node, 0, db.llen(node)):
                print info("Removing %s from %s" % (child, node))
                db.lrem(node,child)
    else:
        child_lists = ["widgets.%s.children" % parent.replace("widgets.","") for parent in parents]
        for node in child_lists:
            if child in db.lrange(node, 0, db.llen(node)):
                print info("Removing %s from %s" % (child, node))
                db.lrem(node,child)

# mogu view-children parent-name
if command == "view-children":
    parent = args.command[1].replace("widgets.","")
    parent = "widgets.%s.children" % parent
    print(db.lrange(parent,0,db.llen(parent)))


# mogu insert-child child-name (before|after) sibling-name in parent-name
if command == "insert-child":
    child = "widgets.%s" % args.command[1].replace("widgets.","")
    preposition = args.command[2]
    sibling = "widgets.%s" % args.command[3]
    if args.command[4] == "in":
        parent = 5
    else:
        parent = 4
    parent = "widgets.%s" % args.command[parent].replace("widgets.","")
    
    try:
        assert(db.exists(parent))
        assert(db.exists(child))
    except AssertionError as e:
        message = fail("Please make sure that both ")
        message += info(child) + " and " + info(parent)
        message += fail(" exist before trying again!")
        print(message)
        sys.exit()

    list_node = "%s.children" % parent
    current_list = db.lrange(list_node,0,db.llen(list_node))
    sibloc = current_list.index(sibling)
    if preposition == "after":
        sibloc += 1
    current_list.insert(sibloc,child)
    if confirm(warn("After this operation, the child list of %s will look like this: %s" % (parent, str(current_list)))):
        db.linsert(list_node, preposition, sibling, child)

#mogu relate widget-1 widget-2
if command == "relate":
    widget1 = "widgets.%s" % args.command[1].replace("widgets.","")
    widget2 = "widgets.%s" % args.command[2].replace("widgets.","")
    parents=[None,None]
    message = None
    children_lists = [key for key in db.keys("*.children")]
    for child in (widget1,widget2):
        for  _list in children_lists:
            if child in db.lrange(_list,0,db.llen(_list)):
                if child is widget1:
                    parents[0] = _list.replace(".children","")
                else:
                    parents[1] = _list.replace(".children","")
    if parents[0] == parents[1]:
        message = info(widget1) + " and " +info(widget2) + " are " + info("siblings")
    elif parents[0] == widget2:
        message = info(widget1) + " is a direct descendent of " + info(widget2)
    elif parents[1] == widget1:
        message = info(widget2) + " is a direct descendent of " + info(widget1) 
    else:
        complex_relation_analysis(db,widget1,widget2)
    if message:
        print(message)

#mogu get-child-index child-name [child-name ...]
if command == "get-child-index":
    for widget in args.command[1:]:
        widget = "widgets.%s" % widget.replace("widgets.","")
        parent = find_parent(db, widget)
        siblings = full_list(db, "%s.children" % parent)
        index = siblings.index(widget)
        output = info(widget) + " :\t%s" % ok(str(index))
        print output

#mogu delete key
if command == "delete":
    key = args.command[1]
    if (db.exists(key)):
        warning = warn("%s will be permanently deleted. THERE IS NO UNDO!")
        if confirm(warning, args.yes):
            db.delete(key)
        else:
            print(ok("No changes were made."))
    else:
        print(fail("%s does not exist in this database." % key))
        print("For your safety, we have disabled auto key-complete when deleting. You must use the full key name.")

if command == "start":
    meta_keys = ("analytics",)
    print(info("Importing meta values..."))
    for key in meta_keys:
        if config.has_option("meta_keys",key):
            val = config.get("meta_keys", key)
            print(info("meta.%s -> %s" % (key,val)))
            db.set("meta.%s" % key, val)

    cli_command = "mogu-server --docroot \"%s;/resources\" --http-address %s --http-port %s" % (
            config.get("local_server","root"), config.get("local_server", "address"), config.get("local_server", "port"))
    if config.get("local_server","debug") == "on":
        cli_command += " --gdb"
    print(cli_command)
    os.system(cli_command)

if command == "newfile":
    filenames = args.command[1:] 
    for filename in filenames:
        f = open(filename,"w")
        f.write("#!/usr/bin/env python\n")
        f.write("# Mogu Import File %s" % filename)
        f.write("\n\n")
        f.close()

if command == "export-widget":
    try:
        widgets = args.command[1:]
    except:
        error = fail("You have told me that you want to export a widget from the database, but have not told me what widget to export.")
        print("%s\nYou can fix this by making sure to pass the widget name: mogu export-widget widget_name --filename file")
        sys.exit()
    filename = args.filename
    if not args.filename:
        error = fail("You have told me that you want to export a widget from the database, but have not given me a filename to write to.")
        print("%s\n You can fix this by using the --filename option. ex: ./mogu export --filename /path/to/file")%error
        sys.exit()
    
    f = open(filename, "w")
    f.write("#!/usr/bin/env python\n")
    f.write("# Mogu Import File %s" % filename)
    f.write("\n\n")
    for widget in widgets:
        widget = "widgets.%s" % (widget.replace("widgets.",""))
        output = []
        output.append( export_widget_dict(db,widget) )
        output.append( export_widget_events(db, widget) )
        output.append( export_widget_children(db, widget) )
        output_str = "\n\n".join(output)
        f.write(output_str)
    
    f.close()
    clean_file(filename)
#END export-widget

if command == "merge-sessions":
    merge_all(db)


if command == "purge-sessions":
    gnamespace = "s.global.%s"

    if not confirm( 
            fail(
                "You are about to permanently remove ALL non-global sessions from your database.\
This cannot be undone! Be very, very careful here!"), args.yes):
        sys.exit()
    all_sessions = db.keys("s.*")
    to_be_deleted = []
    for session in all_sessions:
        if "global" not in session:
            to_be_deleted.append(session)
            continue
    to_be_deleted.extend([
        gnamespace % Hash.session_lookup,
        gnamespace % Hash.auth_lookup,
        gnamespace % Hash.salt_lookup])
    for key in to_be_deleted:
        db.delete(key)

if command == "init":
    # First, check to make sure there isn't a Mogu application
    # already configured in the database
    if len(db.keys("*")) is not 0:
        if not confirm(
                warn("It appears that there is already information in the currently selected database. Initializing a project here may overwrite data already present. It is recommended that you select a different database (with --redis-select) instead."),
                    args.yes):
            print(ok("No changes were made."))
            sys.exit()
    db.hset("widgets.wrapper","type","{container}")
    print(ok("Mogu project has been initialized! Go Mogu!"))

if command == "find-orphans":
    commands.find_orphans(db)

#dbdiff backup_db_num [redis-options]
if command == "dbdiff":
    backupdb = Redis(args.redis_host, args.redis_port, args.command[1], args.redis_auth)
    orig_keys =db.keys("*")
    bak_keys = backupdb.keys("*")
    for key in orig_keys:
        if key not in bak_keys:
            print fail(key) + " was not found in the backup database!"
    message = ("# Orig. Keys: %d | # Bak. Keys: %d") % (len(orig_keys),len(bak_keys))
    if len(orig_keys) is not len(bak_keys):
        message = fail(message)
    else:
        message = ok(message)
    print message

if command == "whatis":
    for arg in args.command[1:]:
        print whatis(db,arg)
if command == "version":
    print VERSION

